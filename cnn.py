# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RbhxbTdZJNAzEjcv9spS7gNnBMktihUq
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import urllib
import requests
from io import BytesIO

def url_to_image(url, gray=False): #url에서 이미지를 받아오고 gary값에 따라 그레이스케일로 변형or not 을 정함
    resp = urllib.request.urlopen(url)
    image = np.asarray(bytearray(resp.read()), dtype="uint8") #url을 읽어와서bytearray형태->np.asarray로 저장 unit8 타입으로 변환
    
    if gray == True:
        image = cv2.imdecode(image, cv2.IMREAD_GRAYSCALE)
    else:
        image = cv2.imdecode(image, cv2.IMREAD_COLOR)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
    return image

def filtered_image(image, filter, output_size):
  filtered_img = np.zeros((output_size, output_size))
  filter_size = filter.shape[0] # filter의 shape을 filter사이즈로 가져옴

  for i in range(output_size):
     for j in range(output_size):
       multiply_values = image[i:(i + filter_size), j:(j + filter_size)] * filter #outputsize만큼 filtersize만큼 연산해줌
       sum_value = np.sum(multiply_values) # 곲의 전체 합
       
       if(sum_value > 255):
         sum_value = 255

         filtered_img[i, j] = sum_value

  return filtered_img

img_url = "https://upload.wikimedia.org/wikipedia/ko/thumb/2/24/Lenna.png/440px-Lenna.png"

image = url_to_image(img_url, gray=True)
print("image.shape", image.shape)

plt.imshow(image, cmap='gray')
plt.show()

vertical_filter = np.array([[1.,2.,1.],
                           [0.,0.,0.],
                           [-1.,-2.,-1.]])

horizontal_filter = np.array([[1.,0.,-1.],
                              [2.,0.,-2.],
                              [1.,0.,-1.]])

output_size = int((image.shape[0] -3) / 1 + 1)
print("output size:", output_size)

vertical_filtered = filtered_image(image, vertical_filter, output_size)
horizontal_filtered = filtered_image(image, horizontal_filter, output_size)

plt.figure(figsize=(10,10))
plt.subplot(1,2,1)
plt.title("Vertical")
plt.imshow(vertical_filtered, cmap='gray')

plt.subplot(1,2,2)
plt.title("Horizontal")
plt.imshow(horizontal_filtered, cmap='gray')
plt.show()

sobel_img = np.sqrt(np.square(horizontal_filtered) + np.square(vertical_filtered))

plt.imshow(sobel_img, cmap='gray')

img_url = "https://upload.wikimedia.org/wikipedia/ko/thumb/2/24/Lenna.png/440px-Lenna.png"

image = url_to_image(img_url)
print("image.shape", image.shape)

plt.imshow(image, cmap='gray')
plt.show()

print(image)
image_copy = image.copy()
image_copy[:,:,1] = 0 # [슬라이싱 전체, ", green=0]
image_copy[:,:,2] = 0 # [슬라이싱 전체, ", blue=0]
image_red = image_copy # [:,:,0]

print(image_red)

image_copy = image.copy()
image_copy[:, :, 0] = 0
image_copy[:, :, 2] = 0
image_green = image_copy

image_copy = image.copy()
image_copy[:, :, 0] = 0
image_copy[:, :, 1] = 0
image_blue = image_copy

fig = plt.figure(figsize=(12, 8))
title_list = ['R', 'G', 'B',
              'R - grascale', 'G - grayscale','B - grayscale']
image_list = [image_red, image_green, image_blue,
              image_red[:, :, 0], image_green[:, :, 1], image_blue[:, :, 2]]

for i, image in enumerate(image_list):
  ax = fig.add_subplot(2, 3, i+1)
  ax.title.set_text("{}".format(title_list[i]))

  if i>=3:
    plt.imshow(image, cmap='gray')
  else:
    plt.imshow(image)

plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
import urllib
import requests
from io import BytesIO

def url_to_image(url, gray=False): #url에서 이미지를 받아오고 gary값에 따라 그레이스케일로 변형or not 을 정함
    resp = urllib.request.urlopen(url)
    image = np.asarray(bytearray(resp.read()), dtype="uint8") #url을 읽어와서bytearray형태->np.asarray로 저장 unit8 타입으로 변환
    
    if gray == True:
        image = cv2.imdecode(image, cv2.IMREAD_GRAYSCALE)
    else:
        image = cv2.imdecode(image, cv2.IMREAD_COLOR)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
    return image

def conv_op(image, kernel, pad=0, stride=1):
  H, W, C = image.shape
  kernel_size = kernel.shape[0]

  out_h = (H + 2*pad - kernel_size) // stride +1
  out_w = (W + 2*pad - kernel_size) // stride +1

  filtered_img = np.zeros((out_h, out_w))
  img = np.pad(image, [(pad, pad), (pad, pad), (0, 0)], 'constant') #pading 값을 위아래 왼쪽 오른쪽에 추가함((0,0)으로) constant value

  for i in range(out_h):
    for j in range(out_w):
      for c in range(C):
        multiply_values = image[i:(i + kernel_size), j:(j + kernel_size), c] * kernel
        sum_value = np.sum(multiply_values)

        filtered_img[i, j] += sum_value
  filtered_img = filtered_img.reshape(1, out_h, out_w, -1).transpose(0, 3, 1, 2)

  return filtered_img.astype(np.uint8)

"""
def filtered_image(image, filter, output_size):
  filtered_img = np.zeros((output_size, output_size))
  filter_size = filter.shape[0] # filter의 shape을 filter사이즈로 가져옴

  for i in range(output_size):
     for j in range(output_size):
       multiply_values = image[i:(i + filter_size), j:(j + filter_size)] * filter #outputsize만큼 filtersize만큼 연산해줌
       sum_value = np.sum(multiply_values) # 곲의 전체 합
       
       if(sum_value > 255):
         sum_value = 255

         filtered_img[i, j] = sum_value

  return filtered_img
"""

Wimg_url = "https://upload.wikimedia.org/wikipedia/ko/thumb/2/24/Lenna.png/440px-Lenna.png"

image = url_to_image(img_url)
print("image.shape", image.shape)

plt.imshow(image, cmap='gray')
plt.show()

filter1 = np.random.randn(3, 3, 3)

print(filter1.shape)
print(filter1)

filtered_img1 = conv_op(image, filter1)
print(filtered_img1.shape)

plt.figure(figsize = (10,10))
plt.subplot(1, 2, 1)
plt.title("used filter")
plt.imshow(filter1, cmap='gray')

plt.subplot(1, 2, 2)
plt.title("Result")
plt.imshow(filtered_img1[0, 0, :, :], cmap='gray')
plt.show()

filter2 = np.random.randn(3, 3, 3)

print(filter2.shape)
print(filter2)

filtered_img2 = conv_op(image, filter2)
print(filtered_img2.shape)

plt.figure(figsize = (10,10))
plt.subplot(1, 2, 1)
plt.title("used filter")
plt.imshow(filter2, cmap='gray')

plt.subplot(1, 2, 2)
plt.title("Result")
plt.imshow(filtered_img2[0, 0, :, :], cmap='gray')
plt.show()

filter3 = np.random.randn(3, 3, 3)

print(filter3.shape)
print(filter3)

filtered_img3 = conv_op(image, filter3)
print(filtered_img3.shape)

plt.figure(figsize = (10,10))
plt.subplot(1, 2, 1)
plt.title("used filter")
plt.imshow(filter3, cmap='gray')

plt.subplot(1, 2, 2)
plt.title("Result")
plt.imshow(filtered_img3[0, 0, :, :], cmap='gray')
plt.show()

filter4 = np.random.randn(3, 3, 3)

print(filter4.shape)
print(filter4)

filtered_img4 = conv_op(image, filter4)
print(filtered_img4.shape)

plt.figure(figsize = (10,10))
plt.subplot(1, 2, 1)
plt.title("used filter")
plt.imshow(filter4, cmap='gray')

plt.subplot(1, 2, 2)
plt.title("Result")
plt.imshow(filtered_img4[0, 0, :, :], cmap='gray')
plt.show()

filter5 = np.random.randn(3, 3, 3)

print(filter5.shape)
print(filter5)

filtered_img5 = conv_op(image, filter5)
print(filtered_img5.shape)

plt.figure(figsize = (10,10))
plt.subplot(1, 2, 1)
plt.title("used filter")
plt.imshow(filter5, cmap='gray')

plt.subplot(1, 2, 2)
plt.title("Result")
plt.imshow(filtered_img5[0, 0, :, :], cmap='gray')
plt.show()

filtered_img = np.stack([filtered_img1, filtered_img2, filtered_img3, filtered_img4, filtered_img5]).sum(axis=0)
print(filtered_img.shape)

plt.imshow(filtered_img[0, 0, :, :], cmap='gray')
plt.show()

np.random.seed(222)

fig = plt.figure(figsize=(8, 20))

filter_num = 5
filtered_img = []

for i in range(filter_num):
  ax = fig.add_subplot(5, 2, 2*i+1)
  ax.title.set_text("Filter {}".format(i+1))

  filter = np.random.randn(3, 3, 3)
  plt.imshow(filter);

  ax = fig.add_subplot(5, 2, 2*i+2)
  ax.title.set_text("Result")

  filtered = conv_op(image, filter)
  filtered_img.append(filtered)
  plt.imshow(filtered[0, 0, :, :], cmap='gray')

plt.show()

filtered_img = np.stack(filtered_img).sum(axis=0)
print(filtered_img.shape)

plt.imshow(filtered_img[0, 0, :, :], cmap='gray')
plt.show()

"""# Convolution Layer"""

def im2col(input_data, filter_h, filter_w, stride=1, pad=0):

  N, C, H, W = input_data.shape
  out_h = (H + 2*pad - filter_h) // stride +1
  out_w = (W + 2*pad - filter_w) // stride +1
  
  img = np.pad(input_data, [(0, 0), (0, 0), (pad, pad), (pad, pad)], 'constant')
  col = np.zeros((N, C, filter_h, filter_w, out_h, out_w))

  for y in range(filter_h):
    y_max = y +stride*out_h
    for x in range(filter_w):
      x_max = x + stride * out_w
      col[:, :, y, x, :, :] = img[:, :, y:y_max:stride, x:x_max:stride]

  col = col.transpose(0, 4, 5, 1, 2, 3).reshape(N * out_h * out_w, -1)
  return col

def col2im(col, input_shape, filter_h, filter_w, stride=1, pad=0):

  N, C, H, W = input_shape
  out_h = (H + 2*pad - filter_h) // stride +1
  out_w = (W + 2*pad - filter_w) // stride +1
  col = col.reshape(N, out_h, out_w, C, filter_h, filter_w).transpose(0, 3, 4, 5, 1, 2)

  img = np.zeros((N, C, H + 2* pad +stride -1, W + 2*pad +stride -1))
  for y in range(filter_h):
    y_max = y +stride*out_h
    for x in range(filter_w):
      x_max = x + stride * out_w
      img[:, :, y:y_max:stride, x:x_max:stride] += col[:, :, y, x, :, :]
  
  return img[:, :, pad:H + pad, pad:W + pad]

class Conv2D:
  def __init__(self, W, b, stride=1, pad=0):
    self.W = W
    self.b = b
    self.stride = stride
    self.pad =pad

    self.input_data =None
    self.col = None
    self.col_W = None
    
    self.dW = None
    self.db = None

  def forward(self, input_data):
    FN, C, FH, FW = self.W.shape
    N, C, H, W = input_data.shape
    out_w = (W + 2*self.pad - FW) // self.stride + 1
    out_h = (H + 2*self.pad - FH) // self.stride + 1

    col =im2col(input_data, FH, FW, self.stride, self.pad)
    col_W = self.W.reshape(FN, -1).T

    out = np.dot(col, col_W) + self.b
    output = out.reshape(N, out_h, out_w, -1).transpose(0, 3, 1, 2)

    self.input_data = input_data
    self.col = col
    self.col_W =col_W

    return output

  def backward(self, dout):
    FN, C, FH, FW = self.W.shape
    dout = dout.transpose(0, 2, 3, 1).reshape(-1, FN)

    self.db = np.sum(dout, axis=0)
    self.dW = np.dot(self.col.T, dout)
    self.dW = self.dW.transpose(1, 0).reshape(FN, C, FH, FW)

    dcol = np.dot(dout, self.col_W.T)
    dx = col2im(dcol, self.input_data.shape, FH, FW, self.stride, self.pad)

    return dx

def init_weight(num_filters, dat_dim, kernel_size, stride = 1, pad =0, weight_std=0.01):

  weights = weight_std * np.random.randn(num_filters, dat_dim, kernel_size, kernel_size)
  biases = np.zeros(num_filters)

  return weights, biases

Wimg_url = "https://upload.wikimedia.org/wikipedia/ko/thumb/2/24/Lenna.png/440px-Lenna.png"
image_gray = url_to_image(img_url, gray=True)
image_gray = image_gray.reshape(image_gray.shape[0], -1, 1)
print("image.shape", image_gray.shape)

image_gray = np.expand_dims(image_gray.transpose(2, 0, 1), axis=0)



plt.imshow(image_gray[0, 0, :, :], cmap='gray')
plt.show()

W, b = init_weight(1, 1, 3)
conv = Conv2D(W, b)
output = conv.forward(image_gray)

print("Conv Layer size: ", output.shape)

plt.imshow(output[0, 0,:, :], cmap='gray')
plt.show()







